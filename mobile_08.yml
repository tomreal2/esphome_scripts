substitutions:
  mobile_num: "08"
  sensor_sda: "16"
  sensor_scl: "4"
  display_sda: "22"
  display_scl: "1"
  
esphome:
  name: mobile_${mobile_num}
  platform: ESP32
  board: nodemcu-32s
  on_boot:
    - wait_until:
        api.connected:
    - script.execute: set_last_burp_time
    - switch.turn_off: idpower_${mobile_num}
    
wifi:
  ssid: "Fennario"
  password: "likeadove"

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Mobile ${mobile_num} Fallback Hotspot"
    password: "uoya0sL7qBfA"

captive_portal:

# Enable logging
logger:

# Enable Home Assistant API
api:

ota:
  platform: esphome

switch:
  - platform: gpio
    name: "Power_${mobile_num}"
    id: "idpower_${mobile_num}"
    pin: 23 #pin15 - top right
    restore_mode: RESTORE_DEFAULT_ON
    
i2c:
  - id: i2c_sensor
    sda: ${sensor_sda} #16 #pin6 on right #outer wire
    scl: ${sensor_scl} #4  #pin5 on right
    scan: True
  - id: i2c_display
    sda: ${display_sda} #22 #pin14  -2nd from top on right
    scl: ${display_scl} #1  #pin13  -3rd from top on right
    scan: True


sensor:
  - platform: sht3xd
    i2c_id: i2c_sensor
    temperature:
      id: "idtemperature${mobile_num}_1"
      name: "Temperature${mobile_num}_1"
    humidity:
      id: "idhumidity${mobile_num}_1"
      name: "Humidity${mobile_num}_1"
    address: 0x44
    update_interval: 5s
  - platform: template
    name: "Burp_Offset_${mobile_num}"
    id: "idburpoffset_${mobile_num}"
    lambda: "return id(burp_offset);"
    update_interval: 10s
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 5min
        - delta: 1
  - platform: template
    name: "Last Burp ${mobile_num}"
    id: "idlastburp_${mobile_num}"
    lambda: |-
      auto time = id(sntp_time).now();
      int lastburptime = id(last_burp_time);
      int hours_since_last_burp = (id(last_burp_time)==0) ? 0 : ( ((time.timestamp - id(last_burp_time)) / 60) / 60 );
      return hours_since_last_burp;
    update_interval: 60s
    unit_of_measurement: "hrs"
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 5min
        - delta: 1
  - platform: template
    name: "VPD ${mobile_num}"
    id: "vpd_${mobile_num}"
    lambda: |-
      float temp = id(idtemperature${mobile_num}_1).state;
      float hum  = id(idhumidity${mobile_num}_1).state;
      return ((6.1078*exp(17.08085*temp/(234.175+temp)))-(6.1078*exp(17.08085*temp/(234.175+temp))*(hum/100)))/10;
    update_interval: 3s
    unit_of_measurement: "kPa"
    accuracy_decimals: 2

font:
  - file: "Roboto-Regular.ttf"
    id: roboto_regular_font
    size: 20
  - file: "Roboto-Regular.ttf"
    id: roboto_regular_font2
    size: 15
  - file: "Roboto-Regular.ttf"
    id: roboto_regular_font3
    size: 12

       
time:
  - platform: sntp
    id: sntp_time
    on_time: 
      - seconds: 0
        minutes: /1
        then: # Every 1 minute
          - script.execute: periodic_burp_${mobile_num}

display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    i2c_id: i2c_display
    address: 0x3C
    lambda: |-
      // top center.
      it.printf(64, 0, id(roboto_regular_font), TextAlign::TOP_CENTER, "Mobile ${mobile_num}");
      
      it.printf(0, 40, id(roboto_regular_font3), TextAlign::BASELINE_LEFT, "Smarter Burp");
      
      // Print time 
      it.strftime(0, 60, id(roboto_regular_font2), TextAlign::BASELINE_LEFT, "%I:%M %p", id(sntp_time).now());

      // Print humidity
      if (id(idhumidity${mobile_num}_1).has_state()) {
        it.printf(127, 23, id(roboto_regular_font), TextAlign::TOP_RIGHT , "%.1f%%", id(idhumidity${mobile_num}_1).state);
      }

      // Print temperature
      if (id(idtemperature${mobile_num}_1).has_state()) {
        it.printf(120, 60, id(roboto_regular_font), TextAlign::BASELINE_RIGHT , "%.1fÂ°", (id(idtemperature${mobile_num}_1).state * (9.0/5.0) + 32.0));
      }

globals:
  - id: "is_burping"
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: "burp_offset"
    type: int
    restore_value: yes
    initial_value: "0"
  - id: "humidity_before_last_burp"
    type: float
    restore_value: no
    initial_value: "0.0"
  - id: "last_burp_time"
    type: int
    restore_value: yes
    initial_value: "0"
    
script:
  - id: set_last_burp_time
    then:
      - lambda: "auto time = id(sntp_time).now(); id(last_burp_time) = time.timestamp;"
  - id: periodic_burp_${mobile_num}
    then:
      - if:
          condition:
            lambda: 'return id(vpd_${mobile_num}).state < 0.94;' #'return id(idhumidity${mobile_num}_1).state > 63.49;' # 64.0 # 63.75 #Burp above 64.75
          then:
            - script.execute: burp_${mobile_num}
          else:
            - if:
                condition:
                  switch.is_on: idpower_${mobile_num}
                then:
                  - switch.turn_off: idpower_${mobile_num}
                
  - id: adjust_offset
    then:
      - logger.log:
          level: DEBUG
          format: 'Adjusting Offset: hum before burp %f and cur hum %f'
          args: ['id(humidity_before_last_burp)', 'id(idhumidity${mobile_num}_1).state']
      - lambda: |-
                float diff = id(humidity_before_last_burp) - id(idhumidity${mobile_num}_1).state;
                int offset = id(burp_offset);
                
                if ( id(idhumidity${mobile_num}_1).state > 65.0 ) {
                  offset = 2.0;
                } else if ( diff < 0.2 ) {
                  offset = offset + 2.0; 
                } else if ( diff < 0.5 ) {
                  offset = offset + 1.0; 
                } else if ( diff > 1.5 ) {
                  offset = offset - 2.0; 
                } else if ( diff > 1.0 ) {
                  offset = offset - 1.0; 
                }
                
                offset = (offset >  2.0) ?  2.0 : offset;
                offset = (offset < -2.0) ? -2.0 : offset;
                id(burp_offset) = offset;
  - id: burp_${mobile_num}
    then:
      - if:
          condition:
            lambda: 'return id(idhumidity${mobile_num}_1).state > 59.0 && id(burp_offset) == 0;'
          then:
            - lambda: "id(is_burping) = true; id(humidity_before_last_burp) = id(idhumidity${mobile_num}_1).state;"
            - script.execute: set_last_burp_time
            - switch.turn_on: idpower_${mobile_num}
            - delay: 15 sec
            - switch.turn_off: idpower_${mobile_num}
            - lambda: "id(is_burping) = false;"
            - delay: 41 sec
            - script.execute: adjust_offset
          else:
            - if:
                condition:
                  lambda: 'return id(idhumidity${mobile_num}_1).state > 59.0 && id(burp_offset) == 1;'
                then:
                  - lambda: "id(is_burping) = true; id(humidity_before_last_burp) = id(idhumidity${mobile_num}_1).state;"
                  - script.execute: set_last_burp_time
                  - switch.turn_on: idpower_${mobile_num}
                  - delay: 20 sec
                  - switch.turn_off: idpower_${mobile_num}
                  - lambda: "id(is_burping) = false;"
                  - delay: 36 sec
                  - script.execute: adjust_offset
                else:  
                  - if:
                      condition:
                        lambda: 'return id(idhumidity${mobile_num}_1).state > 59.0 && id(burp_offset) == 2;'
                      then:
                        - lambda: "id(is_burping) = true; id(humidity_before_last_burp) = id(idhumidity${mobile_num}_1).state;"
                        - script.execute: set_last_burp_time
                        - switch.turn_on: idpower_${mobile_num}
                        - delay: 40 sec
                        - switch.turn_off: idpower_${mobile_num}
                        - lambda: "id(is_burping) = false;"
                        - delay: 16 sec
                        - script.execute: adjust_offset
                      else:
                        - if:
                            condition:
                              lambda: 'return id(idhumidity${mobile_num}_1).state > 59.0 && id(burp_offset) == -1;'
                            then:
                              - lambda: "id(is_burping) = true; id(humidity_before_last_burp) = id(idhumidity${mobile_num}_1).state;"
                              - script.execute: set_last_burp_time
                              - switch.turn_on: idpower_${mobile_num}
                              - delay: 10 sec
                              - switch.turn_off: idpower_${mobile_num}
                              - lambda: "id(is_burping) = false;"
                              - delay: 46 sec
                              - script.execute: adjust_offset
                            else:
                              - if:
                                  condition:
                                    lambda: 'return id(idhumidity${mobile_num}_1).state > 59.0 && id(burp_offset) == -2;'
                                  then:
                                    - lambda: "id(is_burping) = true; id(humidity_before_last_burp) = id(idhumidity${mobile_num}_1).state;"
                                    - script.execute: set_last_burp_time
                                    - switch.turn_on: idpower_${mobile_num}
                                    - delay: 2 sec
                                    - switch.turn_off: idpower_${mobile_num}
                                    - lambda: "id(is_burping) = false;"
                                    - delay: 54 sec
                                    - script.execute: adjust_offset